### 动态规划 Dyniamic Programming

#### 数字三角形问题

[LintCode Triangle](http://www.lintcode.com/en/problem/triangle/)，[POJ The Triangle](http://poj.org/problem?id=1163)

把当前的位置(i, j)看成一个状态，然后定义状态(i, j)的指标函数d(i, j)为从格子(i, j)出发时能得到的最大和（包括格子(i, j)本身的值）。在这个状态定义下，原问题的解是d(1, 1)。

d(i, j) = a(i, j) + max{d(i + 1, j), d(i + 1, j + 1)}

##### 递归计算

```
int solve(int i, int j) {
  return a[i][j] + (i == n ? 0 : max(solve(i + 1, j), solve(i + 1, j + 1)));
}
```

##### 递推计算

```
for (int j = 1; j <= n; j++) d[n][j] = a[n][j];
for (int i = n - 1; i >= 1; i--)
  for (int j = 1; j <= i; j++)
    d[i][j] = a[i][j] + max(d[i + 1][j], d[i + 1][j + 1]);
``

可以用递推法计算状态转移方程。递归的关键是边界和计算顺序。在多数情况下，递推法的时间复杂度是：状态总数×每个状态的决策个数×决策时间。如果不同状态的决策个数不同，需具体问题具体分析。

##### 记忆化（memoization）搜索

程序分成两部分。首先用`memset(d, -1, sizeof(d))`，把d全部初始化为-1，然后编写递归函数：

```
int solve(int i, int j) {
  if (d[i][j] >= 0) return d[i][j];
  return d[i][j] = a[i][j] + (i == n ? 0 : max(solve(i + 1, j), solve(i + 1, j + 1)));
}
```

可以用记忆化搜索的方法计算状态转移方程。当采用记忆化搜索时，不必事先确定各状态的计算顺序，但需要记录每个状态“是否已经计算过”。

### DAG上的动态规划

#### 嵌套矩形问题

矩形之间的“可嵌套”关系是一个典型的二元关系，二元关系可以用图来建模。如果矩形X可以嵌套在矩形Y里，就从X到Y连一条有向边。这个有向图是无环的，因为一个矩形无法直接或间接地嵌套在自己内部。换句话说，它是一个DAG。这样，所要求的便是DAG上的最长路径。

#### 硬币问题

将每种面值看作一个点，表示“还需要凑足的面值”，则初始状态为S，目标状态为0。若当前在状态i，每使用一个硬币j，状态便转移到i-Vj。

### 最长路及其字典序

在记忆化搜索中，可以在正在处理的表项声明一个引用，简化对它的读写操作。